"use strict";(self.webpackChunkluminescent_team=self.webpackChunkluminescent_team||[]).push([[418252],{603905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(667294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=d(n),c=i,h=p["".concat(s,".").concat(c)]||p[c]||m[c]||o;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[p]="string"==typeof e?e:i,l[1]=r;for(var d=2;d<o;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},836164:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=n(487462),i=(n(667294),n(603905));const o={},l="ExeFS Modding Guide",r={unversionedId:"exefs/guide",id:"exefs/guide",title:"ExeFS Modding Guide",description:"Introduction",source:"@site/rom-hacking/exefs/guide.md",sourceDirName:"exefs",slug:"/exefs/guide",permalink:"/rom-hacking/exefs/guide",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"ExeFS Editing",permalink:"/rom-hacking/category/exefs"},next:{title:"Setting Up Ghidra",permalink:"/rom-hacking/exefs/ghidra"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Setup",id:"setup",level:2},{value:"Building",id:"building",level:2},{value:"Building with the command prompt",id:"building-with-the-command-prompt",level:3},{value:"Building with CLion",id:"building-with-clion",level:3},{value:"Example Usage",id:"example-usage",level:2},{value:"Next Steps",id:"next-steps",level:2}],u={toc:d},p="wrapper";function m(e){let{components:t,...o}=e;return(0,i.kt)(p,(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"exefs-modding-guide"},"ExeFS Modding Guide"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"There are a few main components to exefs modding that you will need to have at least a basic understanding of."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Using Ghidra/IDA to research"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://developer.arm.com/documentation/ddi0487/ha/?lang=en"},"ARM opcodes")),(0,i.kt)("li",{parentName:"ul"},"Using ExLaunch to compile C++ code")),(0,i.kt)("p",null,"The basic format is to use ghidra to find an offset where we want to inject custom code. We then write C++ code and build it using ExLaunch. This then gives us ExeFS files we can install on our switch or emulator."),(0,i.kt)("h2",{id:"setup"},"Setup"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/rom-hacking/exefs/ghidra"},"Set up Ghidra")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/rom-hacking/exefs/exlaunch"},"Set up ExLaunch"))),(0,i.kt)("h2",{id:"building"},"Building"),(0,i.kt)("p",null,"The ExLaunch template has build options for ",(0,i.kt)("inlineCode",{parentName:"p"},"atmosphere"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"yuzu"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ryujinx")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"modmanager"),". When you build for any of these targets it will output files and folders in the correct directory structure to be dumped into the mods folder. The two actual files that get built (main.npdm and subsdk9) are ",(0,i.kt)("strong",{parentName:"p"},"the same")," no matter which of the targets you build, so generally it doesn't really matter as long as you know where to put them."),(0,i.kt)("h3",{id:"building-with-the-command-prompt"},"Building with the command prompt"),(0,i.kt)("p",null,"To build your mod files manually through the command prompt, there are a few commands to run. They are detailed below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'# Configure the cmake project\ncmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE:STRING="Debug" -DCMAKE_INSTALL_PREFIX:PATH="out/install/WSL-GCC-Debug" -DCMAKE_TOOLCHAIN_FILE:FILEPATH="cmake/toolchain.cmake" -Bbuild\n\n# Move to the build directory\ncd build\n\n# Build the target you want. Replace <target> with your target.\nmake RomBase_release_<target>\n\n# Optional: Export the built failes as a zip. Replace <target> with your target.\nmake RomBase_zip_<target>\n\n# Optional: Send to the Switch using FTP. Replace <target> with your target (Only supports atmosphere and modmanager).\nmake RomBase_ftp_<target>\n')),(0,i.kt)("p",null,"To build for another target simply replace ",(0,i.kt)("inlineCode",{parentName:"p"},"<target>")," with your build target e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"atmosphere")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"make release_atmosphere\n")),(0,i.kt)("h3",{id:"building-with-clion"},"Building with CLion"),(0,i.kt)("p",null,"I generally recommend using CLion for writing code on ExLaunch over something like Visual Studio Code as the latter has trouble with the way hooks are defined (and C++ in general, really)."),(0,i.kt)("p",null,"Your toolchain settings should look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"An image showing the toolchain settings to use in CLion.",src:n(180648).Z,title:"Toolchain Settings",width:"982",height:"728"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Toolset should be set to your WSL instance."),(0,i.kt)("li",{parentName:"ul"},"CMake should be set to WSL CMake."),(0,i.kt)("li",{parentName:"ul"},"The rest should generally be left as-is unless you know what you're doing.")),(0,i.kt)("p",null,"Your CMake profile settings should look like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"An image showing the CMake profile settings to use in CLion.",src:n(75111).Z,title:"CMake Profile Settings",width:"1173",height:"795"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Build type should be set to Debug."),(0,i.kt)("li",{parentName:"ul"},"Toolchain should be set to WSL."),(0,i.kt)("li",{parentName:"ul"},"Generator should be set to Unix Makefiles."),(0,i.kt)("li",{parentName:"ul"},"CMake options should be the following:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'-G "Unix Makefiles"\n-DCMAKE_TOOLCHAIN_FILE:FILEPATH="cmake/toolchain.cmake"\n-DCMAKE_INSTALL_PREFIX:PATH="out/install/WSL-GCC-Debug"\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Build directory should be set to ",(0,i.kt)("inlineCode",{parentName:"li"},"build"),"."),(0,i.kt)("li",{parentName:"ul"},"Environment should be set to ",(0,i.kt)("inlineCode",{parentName:"li"},"DEVKITPRO=/opt/devkitpro"),"."),(0,i.kt)("li",{parentName:"ul"},"The rest should generally be left as-is unless you know what you're doing.")),(0,i.kt)("p",null,"After this is set up, building is very easy!"),(0,i.kt)("p",null,'In the CMake menu in the bottom left, click the "Reload CMake Project" button:'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"An image showing the &quot;Reload CMake Project&quot; button in CLion.",src:n(946060).Z,title:"Reload CMake Project",width:"251",height:"228"})),(0,i.kt)("p",null,"Once it's reloaded, you can select the target you'd like to build from the dropdown menu at the top and click the \"Build\" button."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"An image showing the targets dropdown and the &quot;Build&quot; button in CLion.",src:n(447520).Z,title:"Available Targets",width:"628",height:"832"})),(0,i.kt)("h2",{id:"example-usage"},"Example Usage"),(0,i.kt)("p",null,"Let's go through an example of disabling the disobeying mechanic."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This patch already exists in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/mod/features/badge_check.cpp")," if you're looking at the Luminescent fork. For demonstration purposes we'll add it as its own patch. Always make sure you're not duplicating existing hooks when creating patches!")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Set up your development enviroment as above.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use Ghidra to find the offset to a function where you want to inject your custom code. This is probably going to be the hardest part, we need to look through the code and find the relevant location for our injection."),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Lets open ghidra and search through the functions using the Symbol Tree on the left sidebar."),(0,i.kt)("li",{parentName:"ol"},"Just from messing around in the files we know ",(0,i.kt)("inlineCode",{parentName:"li"},"Dpr")," is where most game functions are. Within this we know disobeying is a battle mechanic so let's look under ",(0,i.kt)("inlineCode",{parentName:"li"},"Dpr.Battle.Logic"),".  "),(0,i.kt)("li",{parentName:"ol"},"After a bit of searching around we find a function in the ",(0,i.kt)("inlineCode",{parentName:"li"},"MainModule")," called ",(0,i.kt)("inlineCode",{parentName:"li"},"Dpr.Battle.Logic.MainModule$$GetMaxFollowPokeLevel")," which returns a ",(0,i.kt)("inlineCode",{parentName:"li"},"uint8_t"),". This looks like the function that returns the max obeying level, so let's assume it is and test it."),(0,i.kt)("li",{parentName:"ol"},"The function starts at the adress of ",(0,i.kt)("inlineCode",{parentName:"li"},"71020349e0"),", which equates to an offset of ",(0,i.kt)("inlineCode",{parentName:"li"},"020349e0"),"."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add your new feature to the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/mod/features/features.h")," header file and call it from main."),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Let's add our new feature and call it ",(0,i.kt)("inlineCode",{parentName:"li"},"disobeying"),". Usually the function names that we use are prefixed with ",(0,i.kt)("inlineCode",{parentName:"li"},"exl_")," and suffixed with ",(0,i.kt)("inlineCode",{parentName:"li"},"_main"),".")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="src/mod/features/features.h"',title:'"src/mod/features/features.h"'},"// Removes the disobeying mechanic.\nvoid exl_disobeying_main();\n")),(0,i.kt)("ol",{parentName:"li",start:2},(0,i.kt)("li",{parentName:"ol"},"Add a call to this function in ",(0,i.kt)("inlineCode",{parentName:"li"},"exl_feature_main()")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"src/mod/features/main.cpp")," to enable our patch."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Create a ",(0,i.kt)("inlineCode",{parentName:"p"},".cpp")," file in the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/mod/features")," directory which states the offset to inject your code at, and the code to run."),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Let's create a new file ",(0,i.kt)("inlineCode",{parentName:"li"},"src/mod/features/disobeying.cpp"),"."),(0,i.kt)("li",{parentName:"ol"},"At the top of the file, I usually always add this include for feature files:")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="src/mod/features/disobeying.cpp"',title:'"src/mod/features/disobeying.cpp"'},'#include "exlaunch.hpp"\n')),(0,i.kt)("ol",{parentName:"li",start:3},(0,i.kt)("li",{parentName:"ol"},"Define a hook to inject code into the wanted function. There are 3 types of hooks in ExLaunch that are detailed ",(0,i.kt)("a",{parentName:"li",href:"/rom-hacking/exefs/hooks"},"here"),". For our purposes, we'll want a replace hook:")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="src/mod/features/disobeying.cpp"',title:'"src/mod/features/disobeying.cpp"'},"HOOK_DEFINE_REPLACE(Dpr_Battle_Logic_MainModule_GetMaxFollowPokeLevel) {\n  static uint8_t Callback(Dpr::Battle::Logic::MainModule::Object* __this) {\n    // Setting the obedience threshold to always be Lv. 100.\n    return 100;\n  }\n};\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"How to properly define the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"__this")," argument is detailed on the ",(0,i.kt)("a",{parentName:"p",href:"/rom-hacking/exefs/headers"},"headers")," page.")),(0,i.kt)("ol",{parentName:"li",start:4},(0,i.kt)("li",{parentName:"ol"},"Now that the hook is defined, you can install it at the offset where the original function is that we found earlier (",(0,i.kt)("inlineCode",{parentName:"li"},"020349e0"),"). Add the following definition of ",(0,i.kt)("inlineCode",{parentName:"li"},"exl_disobeying_main")," to the bottom of the file:")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="src/mod/features/disobeying.cpp"',title:'"src/mod/features/disobeying.cpp"'},"void exl_disobeying_main() {\n  Dpr_Battle_Logic_MainModule_GetMaxFollowPokeLevel::InstallAtOffset(0x020349e0);\n}\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Build your mod as above.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Install and test your new mod on your target platform."))),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"To accomplish mods that are more complicated you'll need to learn more about AARCH64 opcodes and C++. If you want to access internal functions, you will need to add their offset when defining them as externals. More info on that on the ",(0,i.kt)("a",{parentName:"p",href:"/rom-hacking/exefs/headers"},"headers")," page. When you run into issues, ",(0,i.kt)("a",{parentName:"p",href:"/rom-hacking/exefs/logging"},"logging")," and ",(0,i.kt)("a",{parentName:"p",href:"/rom-hacking/exefs/debugging"},"debugging")," are useful tools to help resolve them."),(0,i.kt)("p",null,"Check the side bar for more info on these topics."))}m.isMDXComponent=!0},447520:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/CLion_Build-00f7e8ef44e3d1ad0264033dc238fa2e.png"},946060:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/CLion_CMake_Reload-aa50c863d2e1b00d3a98af7bad1b7b6e.png"},75111:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/CLion_Profiles-0448c5b8daa235b5cd371399c35dad62.png"},180648:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/CLion_Toolchains-69ca6cb6cdf2b5dd2f7b03cf7bc16f97.png"}}]);